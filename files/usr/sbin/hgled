#!/bin/sh
# hgled - GPIO Wrapper + Internet Indicator (HG680P) - single file (BusyBox friendly)
# Kompatibel:
#   hgled -power on|off|warn|dis
#   hgled -lan   on|off|warn|dis
#   hgled -usb   reset
#   hgled -ir    on|off
#   hgled -r     (restart/daemonize service indikator internet)
#   hgled -s     (stop)
#   hgled -l     (log: loop di foreground)
#
# Patch: start/stop stabil, sleep pecahan detik, start dari offline,
#        NO pause antar siklus (step3=0), transisi mulus (phase-lock + debounce).

SERVICE_NAME="Internet Indicator"
CHECK_URL="${CHECK_URL:-http://www.gstatic.com/generate_204}"
HTTP_TIMEOUT="${HTTP_TIMEOUT:-5}"
FALLBACK_INTERVAL="${FALLBACK_INTERVAL:-0.1}"
PIDFILE="/var/run/internet-indicator.pid"
STATEFILE="/var/run/internet-indicator.state"
GPIO="/sys/class/gpio"

# --- root check ---
is_root(){ [ "$(id -u)" -eq 0 ] || { echo "Run as root"; exit 1; }; }
need_root_or_exit(){ [ "$(id -u)" -eq 0 ] || { echo "This command must be run as root" 1>&2; exit 1; }; }

# --- GPIO helpers ---
gpio_setup(){ p="$1"; [ -z "$p" ] && return 0; [ -d "$GPIO/gpio$p" ] || echo "$p" > "$GPIO/export" 2>/dev/null; echo out > "$GPIO/gpio$p/direction" 2>/dev/null; }
gpio_write(){ p="$1"; v="$2"; [ -z "$p" ] && return 0; echo "$v" > "$GPIO/gpio$p/value" 2>/dev/null; }
dual_general(){
  m="$1"; on="$2"; off="$3"
  gpio_setup "$on"; gpio_setup "$off"
  case "$m" in
    on)   [ -n "$off" ] && gpio_write "$off" 0; [ -n "$on" ] && gpio_write "$on" 1 ;;
    off)  [ -n "$on" ] && gpio_write "$on" 0; [ -n "$off" ] && gpio_write "$off" 1 ;;
    warn) [ -n "$on" ] && gpio_write "$on" 1; [ -n "$off" ] && gpio_write "$off" 1 ;;
    dis)  [ -n "$on" ] && gpio_write "$on" 0; [ -n "$off" ] && gpio_write "$off" 0 ;;
  esac
}

# --- feature mapping ---
power(){ need_root_or_exit; dual_general "$1" "521" "517"; }   # hijau=521, merah=517
lan()  { need_root_or_exit; dual_general "$1" "547" "548"; }   # hijau=547, merah=548
usb(){ need_root_or_exit; u="505"; gpio_setup "$u"; [ "$1" = reset ] && { gpio_write "$u" 0; sleep 1; gpio_write "$u" 1; }; }
ir()   { need_root_or_exit; dual_general "$1" "" "507"; }      # hanya pin_off

# --- shim hgledon (internal) ---
hgledon(){
  case "$1" in
    -power) power "$2" ;;
    -lan)   lan   "$2" ;;
    -usb)   usb   "$2" ;;
    -ir)    ir    "$2" ;;
    *) echo "hgledon usage: -power|-lan [on|off|warn|dis] | -usb reset | -ir on|off" 1>&2; return 1 ;;
  esac
}

# --- fractional sleep (BusyBox) ---
sleep_compat(){
  d="$1"
  case "$d" in
    0) return 0 ;;
    0.5) if command -v usleep >/dev/null 2>&1; then usleep 500000; else sleep 1; fi ;;
    *) sleep "$d" ;;
  esac
}

# --- service core ---
cleanup(){
  hgledon -lan dis 2>/dev/null
  hgledon -power dis 2>/dev/null
  [ -n "${HEALTH_PID:-}" ] && kill "${HEALTH_PID}" 2>/dev/null
  rm -f "$STATEFILE" 2>/dev/null
}

check_online(){
  if command -v curl >/dev/null 2>&1; then
    curl --silent --show-error --head --fail --connect-timeout 3 --max-time "$HTTP_TIMEOUT" -o /dev/null "$CHECK_URL"
  else
    wget -q --spider "$CHECK_URL"
  fi
}

start_health_check_bg(){
  if [ -n "${HEALTH_PID:-}" ] && kill -0 "${HEALTH_PID}" 2>/dev/null; then return; fi
  ( if check_online; then printf "online" >"$STATEFILE"; else printf "offline" >"$STATEFILE"; fi ) &
  HEALTH_PID=$!
}

# NO pause antar siklus: step3=0 (online & offline)
step_delay(){
  case "$1:$2" in
    online:0)  printf "2" ;;
    online:1)  printf "0" ;;
    online:2)  printf "2" ;;
    online:3)  printf "0"   ;;  # <— tanpa jeda di akhir siklus
    offline:0) printf "1" ;;
    offline:1) printf "0" ;;
    offline:2) printf "1" ;;
    offline:3) printf "0"   ;;  # <— tanpa jeda di akhir siklus
    *)         printf "%s" "$FALLBACK_INTERVAL" ;;
  esac
}

do_step(){
  m="$1"; s="$2"
  case "$m:$s" in
    online:0)  hgledon -power on  ;;
    online:1)  hgledon -power dis ;;
    online:2)  hgledon -lan   on  ;;
    online:3)  hgledon -lan   dis ;;
    offline:0) hgledon -power off ;;
    offline:1) hgledon -power dis ;;
    offline:2) hgledon -lan   off ;;
    offline:3) hgledon -lan   dis ;;
    *) : ;;
  esac
}

loop(){
  trap 'cleanup; exit 0' INT TERM
  hgledon -lan dis
  hgledon -power dis

  # Mulai dari OFFLINE agar langsung terlihat
  printf "offline" >"$STATEFILE" 2>/dev/null || true
  mode="offline"; step=0; HEALTH_PID=""
  last_desired="offline"; flip_streak=0   # debounce: butuh 2 hasil sama untuk ganti mode

  start_health_check_bg

  while :; do
    # --- baca status & debounce ---
    desired=""
    [ -s "$STATEFILE" ] && desired="$(cat "$STATEFILE" 2>/dev/null)"
    if [ "$desired" = "online" ] || [ "$desired" = "offline" ]; then
      if [ "$desired" != "$mode" ]; then
        if [ "$desired" = "$last_desired" ]; then
          flip_streak=$((flip_streak+1))
        else
          flip_streak=1
          last_desired="$desired"
        fi
        # ganti mode hanya jika 2x hasil sama berturut-turut
        if [ "$flip_streak" -ge 2 ]; then
          prev_step="$step"
          mode="$desired"
          flip_streak=0
          # Phase-lock: hindari flicker/padam saat transisi di step berapa pun
          case "$prev_step" in
            0|2) step="$prev_step" ;;                   # tetap di fase aktif
            1|3) step=$(( (prev_step + 1) % 4 )) ;;     # lompat dari "dis" ke fase aktif berikutnya
            *)   step=0 ;;
          esac
          # Catatan: TIDAK reset LED (tidak hgledon -lan/power dis) agar transisi mulus.
        fi
      else
        flip_streak=0
        last_desired="$mode"
      fi
    fi

    # --- jalankan 1 langkah pola ---
    do_step "$mode" "$step"
    delay="$(step_delay "$mode" "$step")"
    step=$(( (step + 1) % 4 ))
    [ "$delay" != "0" ] && sleep_compat "$delay"

    # --- refresh health-check ---
    if [ -z "${HEALTH_PID:-}" ] || ! kill -0 "${HEALTH_PID}" 2>/dev/null; then
      start_health_check_bg
    fi
  done
}

# --- daemon start/stop (paling kompatibel BusyBox) ---
start(){
  is_root
  mkdir -p "$(dirname "$PIDFILE")"

  if [ -f "$PIDFILE" ] && kill -0 "$(cat "$PIDFILE" 2>/dev/null)" 2>/dev/null; then
    echo "$SERVICE_NAME already running (pid $(cat "$PIDFILE"))."
    return 0
  fi

  rm -f "$PIDFILE" 2>/dev/null

  # Jalankan loop di background (plain &), tangkap PID yang benar
  "$0" -l </dev/null >/dev/null 2>&1 &
  PID=$!
  echo "$PID" > "$PIDFILE"

  # Beri sedikit waktu agar /proc/$PID tersedia
  if command -v usleep >/dev/null 2>&1; then usleep 200000; else sleep 1; fi

  if [ -n "$PID" ] && kill -0 "$PID" 2>/dev/null; then
    echo "Started $SERVICE_NAME (pid $PID)."
  else
    echo "ERROR: failed to start $SERVICE_NAME" 1>&2
    rm -f "$PIDFILE" 2>/dev/null
    return 1
  fi
}

stop(){
  stopped=""
  if [ -f "$PIDFILE" ]; then
    pid="$(cat "$PIDFILE" 2>/dev/null)"
    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
      kill "$pid"
      for i in 1 2 3; do kill -0 "$pid" 2>/dev/null || break; sleep 1; done
      stopped="yes"
    fi
    rm -f "$PIDFILE"
  fi
  # fallback: cari proses foreground -l
  pids="$(ps w | grep '[h]gled -l' | awk '{print $1}')"
  [ -n "$pids" ] && echo "$pids" | xargs -r kill && stopped="yes"

  cleanup

  if [ -n "$stopped" ]; then echo "Stopped $SERVICE_NAME."; else echo "$SERVICE_NAME not running."; fi
}

print_usage(){
  cat <<EOF
Usage:
  GPIO:
    hgled -power  on|off|warn|dis
    hgled -lan    on|off|warn|dis
    hgled -usb    reset
    hgled -ir     on|off
  Service:
    hgled -r      # restart/daemonize
    hgled -s      # stop
    hgled -l      # run loop in foreground (debug/log)
Env:
  CHECK_URL          default: $CHECK_URL
  HTTP_TIMEOUT       default: $HTTP_TIMEOUT
  FALLBACK_INTERVAL  default: $FALLBACK_INTERVAL
EOF
}

# --- CLI dispatcher ---
case "${1:-}" in
  -power) [ -n "$2" ] || { print_usage; exit 1; }; power "$2" ;;
  -lan)   [ -n "$2" ] || { print_usage; exit 1; }; lan   "$2" ;;
  -usb)   [ -n "$2" ] || { print_usage; exit 1; }; usb   "$2" ;;
  -ir)    [ -n "$2" ] || { print_usage; exit 1; }; ir    "$2" ;;
  -l)     loop ;;
  -r)     stop; start ;;
  -s)     stop ;;
  -h|--help|"") print_usage ;;
  *) echo "Unknown option: $1" 1>&2; print_usage; exit 1 ;;
esac
